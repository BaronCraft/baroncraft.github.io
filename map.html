<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Генератор тайлов</title>
    <style>
        body { font-family: Arial; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; }
        .progress { margin: 10px 0; }
        .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Генератор тайлов карты Minecraft</h1>
        
        <div>
            <label>Размер мира в блоках: </label>
            <input type="number" id="worldSize" value="10000" min="1000" max="100000">
        </div>
        
        <div>
            <label>Максимальный зум: </label>
            <input type="number" id="maxZoom" value="4" min="1" max="6">
        </div>
        
        <button onclick="generateTiles()">Сгенерировать тайлы</button>
        <button onclick="downloadAll()">Скачать все тайлы</button>
        
        <div class="progress">
            <progress id="progress" value="0" max="100"></progress>
            <span id="progressText">0%</span>
        </div>
        
        <div id="status" class="status"></div>
        
        <div id="downloadLinks"></div>
    </div>

    <script>
        class TileGenerator {
            constructor() {
                this.tileSize = 256;
                this.worldSize = 10000;
                this.maxZoom = 4;
                this.tiles = {};
            }
            
            generateTile(zoom, x, y) {
                const canvas = document.createElement('canvas');
                canvas.width = this.tileSize;
                canvas.height = this.tileSize;
                const ctx = canvas.getContext('2d');
                
                // Размер мира на текущем уровне зума
                const worldSizeAtZoom = this.worldSize / Math.pow(2, this.maxZoom - zoom);
                const blockSize = this.tileSize / (worldSizeAtZoom / Math.pow(2, zoom));
                
                // Создаем ландшафт
                this.generateLandscape(ctx, zoom, x, y, worldSizeAtZoom, blockSize);
                
                // Добавляем сетку
                this.addGrid(ctx, zoom);
                
                return canvas.toDataURL('image/jpeg', 0.85);
            }
            
            generateLandscape(ctx, zoom, tileX, tileY, worldSize, blockSize) {
                const tilesPerSide = Math.pow(2, zoom);
                const tileWorldSize = worldSize / tilesPerSide;
                
                for (let i = 0; i < this.tileSize; i += 2) {
                    for (let j = 0; j < this.tileSize; j += 2) {
                        // Координаты в мире
                        const worldX = (tileX * tileWorldSize) + (i / this.tileSize) * tileWorldSize;
                        const worldZ = (tileY * tileWorldSize) + (j / this.tileSize) * tileWorldSize;
                        
                        // Генерируем высоту и биом
                        const height = this.getHeight(worldX, worldZ);
                        const biome = this.getBiome(worldX, worldZ, height);
                        
                        ctx.fillStyle = biome.color;
                        ctx.fillRect(i, j, 2, 2);
                    }
                }
            }
            
            getHeight(x, z) {
                // Простой шум для высоты
                return Math.sin(x * 0.01) * Math.cos(z * 0.01) * 50 + 64;
            }
            
            getBiome(x, z, height) {
                const temperature = Math.sin(x * 0.001) * Math.cos(z * 0.001);
                const humidity = Math.cos(x * 0.0007) * Math.sin(z * 0.0007);
                
                if (height < 50) return { color: '#1E90FF', name: 'Океан' }; // Вода
                if (height > 90) return { color: '#FFFFFF', name: 'Горы' }; // Снег
                if (temperature > 0.5) return { color: '#FFD700', name: 'Пустыня' }; // Песок
                if (humidity > 0.3) return { color: '#228B22', name: 'Лес' }; // Зелень
                if (temperature < -0.3) return { color: '#A9A9A9', name: 'Тайга' }; // Камень
                
                return { color: '#32CD32', name: 'Равнина' }; // Трава
            }
            
            addGrid(ctx, zoom) {
                if (zoom < 2) return; // Сетку только на больших zoom
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= this.tileSize; i += 32) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, this.tileSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(this.tileSize, i);
                    ctx.stroke();
                }
            }
            
            generateAllTiles() {
                this.tiles = {};
                let totalTiles = 0;
                let generatedTiles = 0;
                
                // Считаем общее количество тайлов
                for (let zoom = 0; zoom <= this.maxZoom; zoom++) {
                    const tilesPerSide = Math.pow(2, zoom);
                    totalTiles += tilesPerSide * tilesPerSide;
                }
                
                // Генерируем тайлы для каждого уровня зума
                for (let zoom = 0; zoom <= this.maxZoom; zoom++) {
                    this.tiles[zoom] = {};
                    const tilesPerSide = Math.pow(2, zoom);
                    
                    for (let x = 0; x < tilesPerSide; x++) {
                        this.tiles[zoom][x] = {};
                        
                        for (let y = 0; y < tilesPerSide; y++) {
                            const tileData = this.generateTile(zoom, x, y);
                            this.tiles[zoom][x][y] = tileData;
                            
                            generatedTiles++;
                            const progress = (generatedTiles / totalTiles) * 100;
                            this.updateProgress(progress, `Генерация: zoom ${zoom}, тайл ${x}_${y}`);
                        }
                    }
                }
                
                return this.tiles;
            }
            
            updateProgress(percent, status) {
                document.getElementById('progress').value = percent;
                document.getElementById('progressText').textContent = Math.round(percent) + '%';
                document.getElementById('status').textContent = status;
            }
        }
        
        let generator = new TileGenerator();
        let generatedTiles = null;
        
        function generateTiles() {
            generator.worldSize = parseInt(document.getElementById('worldSize').value);
            generator.maxZoom = parseInt(document.getElementById('maxZoom').value);
            
            document.getElementById('progress').style.display = 'block';
            document.getElementById('downloadLinks').innerHTML = '';
            
            // Запускаем в setTimeout чтобы не блокировать UI
            setTimeout(() => {
                generatedTiles = generator.generateAllTiles();
                document.getElementById('status').textContent = 'Генерация завершена!';
                showDownloadLinks();
            }, 100);
        }
        
        function showDownloadLinks() {
            const linksDiv = document.getElementById('downloadLinks');
            linksDiv.innerHTML = '<h3>Скачать тайлы:</h3>';
            
            for (let zoom in generatedTiles) {
                const link = document.createElement('a');
                link.href = '#';
                link.textContent = `Скачать все тайлы для zoom ${zoom} (ZIP)`;
                link.onclick = () => downloadZoomLevel(parseInt(zoom));
                linksDiv.appendChild(link);
                linksDiv.appendChild(document.createElement('br'));
            }
        }
        
        function downloadZoomLevel(zoom) {
            // Создаем ZIP архив с тайлами этого уровня зума
            const zip = new JSZip();
            const folder = zip.folder(zoom.toString());
            
            for (let x in generatedTiles[zoom]) {
                for (let y in generatedTiles[zoom][x]) {
                    const base64Data = generatedTiles[zoom][x][y].split(',')[1];
                    folder.file(`${x}_${y}.jpg`, base64Data, {base64: true});
                }
            }
            
            zip.generateAsync({type: 'blob'}).then(function(content) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `tiles_zoom_${zoom}.zip`;
                link.click();
            });
        }
        
        function downloadAll() {
            if (!generatedTiles) {
                alert('Сначала сгенерируйте тайлы!');
                return;
            }
            
            const zip = new JSZip();
            
            for (let zoom in generatedTiles) {
                const folder = zip.folder(zoom);
                for (let x in generatedTiles[zoom]) {
                    for (let y in generatedTiles[zoom][x]) {
                        const base64Data = generatedTiles[zoom][x][y].split(',')[1];
                        folder.file(`${x}_${y}.jpg`, base64Data, {base64: true});
                    }
                }
            }
            
            zip.generateAsync({type: 'blob'}).then(function(content) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = 'all_tiles.zip';
                link.click();
            });
        }
    </script>
    
    <!-- Библиотека для создания ZIP архивов -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
