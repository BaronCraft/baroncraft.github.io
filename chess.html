
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Шахматы с перетаскиванием, сохранением, темами и конфетти</title>
<style>
  body {
    display: flex; flex-direction: row; font-family: Arial, sans-serif; margin: 20px;
    user-select: none; -webkit-user-select: none;
    background: #fff;
  }
  #container {
    display: flex; flex-direction: column;
  }
  #chessboard {
    border-collapse: collapse;
    margin-bottom: 10px;
    user-select: none;
  }
  #chessboard td {
    width: 60px; height: 60px;
    text-align: center; vertical-align: middle;
    font-size: 42px; cursor: grab;
    user-select: none;
    position: relative;
  }
  #chessboard td.white {
    background-color: var(--light-square, #f0d9b5);
  }
  #chessboard td.black {
    background-color: var(--dark-square, #b58863);
  }
  #chessboard td.highlight {
    background-color: var(--highlight-square, #f7ec6e) !important;
  }
  #chessboard td.check {
    background-color: #ff7070 !important;
  }
  #notation {
    width: 400px; max-height: 480px; overflow-y: auto;
    border: 1px solid #999; padding: 10px;
    font-size: 14px; line-height: 1.3;
    white-space: pre-wrap;
    margin-left: 20px;
    background: #fafafa;
  }
  #header {
    margin-bottom: 10px;
    font-weight: bold; font-size: 16px;
  }
  #menu {
    margin-bottom: 10px;
  }
  button {
    margin-right: 10px;
    font-size: 14px;
    padding: 5px 10px;
    cursor: pointer;
  }
  select {
    font-size: 14px;
    padding: 5px;
  }
  /* Анимация конфетти */
  .confetti-piece {
    position: fixed;
    width: 8px;
    height: 8px;
    background-color: red;
    opacity: 0.9;
    z-index: 9999;
    pointer-events: none;
    animation: confetti-fall 3s linear forwards;
  }
  @keyframes confetti-fall {
    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }
</style>
</head>
  <header>
        <nav>
        <a href="/">Главная</a>
        <a href="chat.html">Мессенджер</a>
		<a href="word.html">Блокнот</a>
		<a href="chess.html">Шахматы</a>
    </nav>
  </header>
<body>

<div id="container">

  <div id="menu">
    <button id="btnClear">Очистить доску</button>
    <label for="themeSelect">Тема доски: </label>
    <select id="themeSelect" aria-label="Выберите тему доски">
      <option value="classic">Классическая</option>
      <option value="blue">Синяя</option>
      <option value="green">Зеленая</option>
      <option value="dark">Темная</option>
    </select>
  </div>

  <table id="chessboard" aria-label="Шахматная доска"></table>

</div>

<div id="notation" aria-label="Нотация ходов">
  <div id="header">Ходы (прокрутка колесом мыши — отмена/возврат ходов)</div>
  <div id="moves"></div>
</div>

<script>
const size = 8;
const pieces = {
  'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
  'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
};
const pieceNames = {
  'K': 'K', 'Q': 'Q', 'R': 'R', 'B': 'B', 'N': 'N', 'P': ''
};

const themes = {
  classic: {light: '#f0d9b5', dark: '#b58863', highlight: '#f7ec6e'},
  blue: {light: '#cce6ff', dark: '#006bb3', highlight: '#80c1ff'},
  green: {light: '#d4edda', dark: '#237b4a', highlight: '#9debac'},
  dark: {light: '#999', dark: '#333', highlight: '#f7ec6e'}
};

let board = [];
let turn = 'white';
let selected = null;
let possibleMoves = [];
let moveHistory = [];
let currentMoveIndex = -1;
let dragEl = null;
let dragFrom = null;

const container = document.getElementById('container');
const boardElem = document.getElementById('chessboard');
const movesElem = document.getElementById('moves');
const btnClear = document.getElementById('btnClear');
const themeSelect = document.getElementById('themeSelect');

function savePosition() {
  try {
    localStorage.setItem('chessboard', JSON.stringify(board));
    localStorage.setItem('turn', turn);
    localStorage.setItem('moveHistory', JSON.stringify(moveHistory));
    localStorage.setItem('currentMoveIndex', currentMoveIndex);
  } catch(e) { }
}

function loadPosition() {
  try {
    let savedBoard = JSON.parse(localStorage.getItem('chessboard'));
    let savedTurn = localStorage.getItem('turn');
    let savedHistory = JSON.parse(localStorage.getItem('moveHistory'));
    let savedIndex = +localStorage.getItem('currentMoveIndex');

    if (savedBoard && Array.isArray(savedBoard) && savedBoard.length === size) {
      board = savedBoard;
      turn = savedTurn || 'white';
      moveHistory = savedHistory || [];
      currentMoveIndex = (typeof savedIndex === 'number') ? savedIndex : moveHistory.length - 1;
      renderFromBoard();
      updateNotation();
      updateCheckHighlight();
      selected = null;
    } else {
      renderBoardStart();
    }
  } catch(e) {
    renderBoardStart();
  }
}

function renderBoardStart() {
  const startPosition = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];
  board = JSON.parse(JSON.stringify(startPosition));
  turn = 'white';
  moveHistory = [];
  currentMoveIndex = -1;
  renderFromBoard();
  updateNotation();
  updateCheckHighlight();
  selected = null;
}

function renderFromBoard(){
  boardElem.innerHTML = '';
  for(let i=0; i<size; i++) {
    const row = document.createElement('tr');
    for(let j=0;j<size;j++) {
      const cell = document.createElement('td');
      cell.className = ((i+j) % 2 === 0) ? 'white' : 'black';
      cell.dataset.x = i;
      cell.dataset.y = j;
      const piece = board[i][j];
      cell.textContent = piece ? pieces[piece] : '';
      row.appendChild(cell);
    }
    boardElem.appendChild(row);
  }
}

function updateCell(x,y) {
  const cell = boardElem.rows[x].cells[y];
  const piece = board[x][y];
  cell.textContent = piece ? pieces[piece] : '';
  cell.classList.remove('highlight', 'check');
}

function clearHighlights() {
  [...boardElem.querySelectorAll('td')].forEach(t => t.classList.remove('highlight', 'check'));
}

function isWhite(piece) { return piece && piece === piece.toUpperCase(); }
function isBlack(piece) { return piece && piece === piece.toLowerCase(); }
function oppositeColor(color) { return color === 'white' ? 'black' : 'white'; }
function inBounds(x,y) { return x >= 0 && x < size && y >= 0 && y < size; }
const files = ['a','b','c','d','e','f','g','h'];
function getCellName(x,y) { return files[y] + (size - x); }

function findKing(color) {
  for(let i=0; i<size; i++){
    for(let j=0; j<size; j++){
      const p = board[i][j];
      if(p && (color==='white' ? isWhite(p) : isBlack(p)) && (p.toLowerCase() === 'k')){
        return [i,j];
      }
    }
  }
  return null;
}

function squareAttacked(x,y, attackerColor) {
  // Пешки
  let dir = (attackerColor==='white') ? -1 : 1;
  for(let dy of [-1,1]){
    let nx = x + dir, ny = y + dy;
    if(inBounds(nx,ny)){
      let p = board[nx][ny];
      if(p && ((attackerColor==='white' && isWhite(p)) || (attackerColor==='black' && isBlack(p))) && p.toLowerCase() === 'p') return true;
    }
  }

  // Конь
  for(let [dx,dy] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
    let nx = x+dx, ny = y+dy;
    if(inBounds(nx, ny)) {
      let p = board[nx][ny];
      if(p && ((attackerColor==='white' && isWhite(p)) || (attackerColor==='black' && isBlack(p))) && p.toLowerCase() === 'n') return true;
    }
  }

  // Слоны и ферзи (диагонали)
  for(let [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
    for(let dist=1; dist<size; dist++){
      let nx=x+dx*dist, ny=y+dy*dist;
      if(!inBounds(nx,ny)) break;
      let p = board[nx][ny];
      if(p){
        if(((attackerColor==='white' && isWhite(p)) || (attackerColor==='black' && isBlack(p)))){
          let lt = p.toLowerCase();
          if(lt==='b' || lt==='q') return true;
          break;
        } else break;
      }
    }
  }

  // Ладьи и ферзи (горизонтали и вертикали)
  for(let [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
    for(let dist=1; dist<size; dist++){
      let nx=x+dx*dist, ny=y+dy*dist;
      if(!inBounds(nx,ny)) break;
      let p = board[nx][ny];
      if(p){
        if(((attackerColor==='white' && isWhite(p)) || (attackerColor==='black' && isBlack(p)))){
          let lt = p.toLowerCase();
          if(lt==='r' || lt==='q') return true;
          break;
        } else break;
      }
    }
  }

  // Король (проверяем ближайшие клетки)
  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      if(dx === 0 && dy === 0) continue;
      let nx=x+dx, ny=y+dy;
      if(inBounds(nx,ny)){
        let p = board[nx][ny];
        if(p && ((attackerColor==='white' && isWhite(p)) || (attackerColor==='black' && isBlack(p))) && p.toLowerCase()==='k') return true;
      }
    }
  }
  return false;
}

function isKingInCheck(color) {
  const kingPos = findKing(color);
  if(!kingPos) return false;
  return squareAttacked(kingPos[0], kingPos[1], oppositeColor(color));
}

function getLegalMoves(x, y, piece) {
  const moves = [];
  const color = isWhite(piece) ? 'white' : 'black';
  function addMove(nx, ny, special='') {
    if (!inBounds(nx, ny)) return false;
    const target = board[nx][ny];
    if (target === '') {
      moves.push({to: [nx, ny], piece, captured: '', special});
      return true;
    } else {
      if ((color === 'white' && isBlack(target)) || (color === 'black' && isWhite(target))) {
        moves.push({to: [nx, ny], piece, captured: target, special});
      }
      return false;
    }
  }

  switch(piece.toLowerCase()) {
    case 'p': {
      const dir = color === 'white' ? -1 : 1;
      const startRow = color === 'white' ? 6 : 1;
      // Вперёд
      if (inBounds(x + dir, y) && board[x + dir][y] === '') {
        let special = (x + dir === (color === 'white' ? 0 : 7)) ? 'promotion' : '';
        moves.push({to: [x + dir, y], piece, captured: '', special});
        if (x === startRow && board[x + 2*dir][y] === '') {
          moves.push({to: [x + 2*dir, y], piece, captured: ''});
        }
      }
      // Взятие по диагонали
      for(let dy of [-1,1]){
        let nx = x + dir, ny = y + dy;
        if(inBounds(nx, ny)){
          let target = board[nx][ny];
          if(target !== '' && ((color==='white' && isBlack(target)) || (color==='black' && isWhite(target)))){
            let special = (nx === (color==='white' ? 0 : 7)) ? 'promotion' : '';
            moves.push({to: [nx, ny], piece, captured: target, special});
          }
        }
      }
      break;
    }
    case 'r':
      for(let [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){ for(let dist=1; dist<size; dist++){
          let nx = x + dx*dist, ny = y + dy*dist;
          if(!inBounds(nx, ny)) break;
          if(board[nx][ny]===''){
            moves.push({to: [nx, ny], piece, captured: ''});
          } else {
            if((color==='white' && isBlack(board[nx][ny])) || (color==='black' && isWhite(board[nx][ny]))){
              moves.push({to: [nx, ny], piece, captured: board[nx][ny]});
            }
            break;
          }
        }
      }
      break;
    case 'n':
      for(let [dx,dy] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
        let nx = x+dx, ny = y+dy;
        if(!inBounds(nx, ny)) continue;
        let target = board[nx][ny];
        if(target==='' || (color==='white'?isBlack(target):isWhite(target))) {
          moves.push({to: [nx, ny], piece, captured: target!==''?target:''});
        }
      }
      break;
    case 'b':
      for(let [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
        for(let dist=1; dist<size; dist++){
          let nx = x + dx*dist, ny = y + dy*dist;
          if(!inBounds(nx, ny)) break;
          if(board[nx][ny]===''){
            moves.push({to: [nx, ny], piece, captured: ''});
          } else {
            if((color==='white' && isBlack(board[nx][ny])) || (color==='black' && isWhite(board[nx][ny]))){
              moves.push({to: [nx, ny], piece, captured: board[nx][ny]});
            }
            break;
          }
        }
      }
      break;
    case 'q':
      for(let [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]){
        for(let dist=1; dist<size; dist++){
          let nx = x + dx*dist, ny = y + dy*dist;
          if(!inBounds(nx, ny)) break;
          if(board[nx][ny]===''){
            moves.push({to: [nx, ny], piece, captured: ''});
          } else {
            if((color==='white' && isBlack(board[nx][ny])) || (color==='black' && isWhite(board[nx][ny]))){
              moves.push({to: [nx, ny], piece, captured: board[nx][ny]});
            }
            break;
          }
        }
      }
      break;
    case 'k':
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          if(dx===0&&dy===0) continue;
          let nx = x+dx, ny = y+dy;
          if(!inBounds(nx, ny)) continue;
          let target = board[nx][ny];
          if(target === '' || (color==='white'?isBlack(target):isWhite(target))){
            moves.push({to: [nx, ny], piece, captured: target!=='' ? target : ''});
          }
        }
      }
      break;
  }
  return moves;
}

function moveLeadsToCheck(sx, sy, dx, dy, piece) {
  const backupFrom = board[sx][sy];
  const backupTo = board[dx][dy];
  board[dx][dy] = piece;
  board[sx][sy] = '';
  const inCheck = isKingInCheck(turn);
  board[sx][sy] = backupFrom;
  board[dx][dy] = backupTo;
  return inCheck;
}

function noLegalMoves(color){
  for(let i=0; i<size; i++){
    for(let j=0; j<size; j++){
      const p = board[i][j];
      if(p && ((color==='white' && isWhite(p)) || (color==='black' && isBlack(p)))){
        let moves = getLegalMoves(i,j,p);
        moves = moves.filter(m => !moveLeadsToCheck(i,j,m.to[0],m.to[1], p));
        if(moves.length>0) return false;
      }
    }
  }
  return true;
}

function generateNotation(from, to, piece, captured, special='') {
  let pieceChar = pieceNames[piece.toUpperCase()] || '';
  let fromFile = files[from[1]];
  let toCell = getCellName(to[0], to[1]);
  let capture = '';

  if(pieceChar === ''){
    if(captured) capture = fromFile + 'x';
  } else {
    capture = captured ? 'x' : '';
  }

  let suffix = '';
  if(special==='promotion') suffix = '=Q';
  if(special==='castle-k') return 'O-O';
  if(special==='castle-q') return 'O-O-O';

  const backupFrom = board[from[0]][from[1]];
  const backupTo = board[to[0]][to[1]];
  board[to[0]][to[1]] = piece;
  board[from[0]][from[1]] = '';
  let opponent = oppositeColor(turn);
  let check = isKingInCheck(opponent);
  let mate = false;
  if(check){
    mate = noLegalMoves(opponent);
  }
  board[from[0]][from[1]] = backupFrom;
  board[to[0]][to[1]] = backupTo;

  if(mate) suffix = '#';
  else if(check) suffix = '+';

  return pieceChar + capture + toCell + suffix;
}

function makeMove(from, to, piece, captured='', special='') {
  // Если отменяли ходы, обрезаем историю (ветвление)
  if (currentMoveIndex < moveHistory.length -1) {
    moveHistory.splice(currentMoveIndex+1);
  }
  const fromPiece = getPiece(from[0], from[1]);
  const targetPiece = getPiece(to[0], to[1]);
  setPiece(to[0], to[1], fromPiece);
  setPiece(from[0], from[1], '');
  const moveNotation = generateNotation(from, to, fromPiece, targetPiece, special);
  moveHistory.push({from, to, piece: fromPiece, captured: targetPiece, notation: moveNotation, special});
  currentMoveIndex++;
  turn = oppositeColor(turn);
  updateNotation();
  updateCheckHighlight();
  savePosition();
  selected = null;
  possibleMoves = [];

  if(isKingInCheck(turn)){
    if(noLegalMoves(turn)){
      runConfetti();
      alert(`Мат! Победил ${oppositeColor(turn)}.`);
    }
  } else if(noLegalMoves(turn)) {
    alert('Пат! Ничья.');
  }
}

function getPiece(x,y){
  return inBounds(x,y)?board[x][y]:null;
}

function setPiece(x,y,piece){
  board[x][y] = piece;
  updateCell(x,y);
}

function updateCheckHighlight(){
  clearHighlights();
  if(isKingInCheck(turn)){
    const kingPos = findKing(turn);
    if(kingPos) {
      boardElem.rows[kingPos[0]].cells[kingPos[1]].classList.add('check');
    }
  }
}

// Перетаскивание фигуры

boardElem.addEventListener('dragstart', e => {
  if (e.target.tagName !== 'TD') return;
  const x = Number(e.target.dataset.x);
  const y = Number(e.target.dataset.y);
  const p = getPiece(x,y);
  if(!p) {
    e.preventDefault();
    return;
  }
  if((turn==='white' && !isWhite(p)) || (turn==='black' && !isBlack(p))){
    e.preventDefault();
    return;
  }
  dragEl = e.target;
  dragFrom = [x,y];
  e.dataTransfer.setData('text/plain', '');
  setTimeout(() => e.target.classList.add('dragging'), 0);
});

boardElem.addEventListener('dragend', e => {
  if(dragEl) dragEl.classList.remove('dragging');
  dragEl = null;
  dragFrom = null;
  clearHighlights();
});

boardElem.addEventListener('dragover', e => {
  e.preventDefault();
  if(!dragFrom) return;
  const td = e.target.closest('td');
  if(!td) return;
  const tx = Number(td.dataset.x);
  const ty = Number(td.dataset.y);
  const fromPiece = getPiece(dragFrom[0], dragFrom[1]);
  if(!fromPiece) return;
  possibleMoves = getLegalMoves(dragFrom[0], dragFrom[1], fromPiece);
  // Фильтруем шахи
  possibleMoves = possibleMoves.filter(m=>!moveLeadsToCheck(dragFrom[0],dragFrom[1],m.to[0],m.to[1], fromPiece));
  clearHighlights();
  possibleMoves.forEach(m=>{
    const [mx,my] = m.to;
    boardElem.rows[mx].cells[my].classList.add('highlight');
  });
  if(possibleMoves.some(m => m.to[0] === tx && m.to[1] === ty)){
    td.classList.add('highlight');
  }
});

boardElem.addEventListener('drop', e => {
  e.preventDefault();
  if(!dragFrom) return;
  const td = e.target.closest('td');
  if(!td) return;
  const toX = Number(td.dataset.x);
  const toY = Number(td.dataset.y);
  const fromPiece = getPiece(dragFrom[0], dragFrom[1]);
  possibleMoves = getLegalMoves(dragFrom[0], dragFrom[1], fromPiece);
  possibleMoves = possibleMoves.filter(m => !moveLeadsToCheck(dragFrom[0], dragFrom[1], m.to[0], m.to[1], fromPiece));
  let move = possibleMoves.find(m => m.to[0] === toX && m.to[1] === toY);
  if(move){
    makeMove(dragFrom, [toX, toY], fromPiece, move.captured || '', move.special || '');
  }
  clearHighlights();
  dragFrom = null;
  dragEl = null;
});

// Сделать все клетки td draggable
function enableDraggable(){
  for(let i=0; i<size; i++){
    for(let j=0; j<size; j++){
      boardElem.rows[i].cells[j].draggable = true;
    }
  }
}

// Undo/Redo ходов колесиком
boardElem.onwheel = (e) => {
  e.preventDefault();
  if(e.deltaY < 0) {
    if(currentMoveIndex >= 0) {
      revertMove(moveHistory[currentMoveIndex]);
      currentMoveIndex--;
      turn = oppositeColor(turn);
      updateNotation();
      updateCheckHighlight();
      selected = null;
      possibleMoves = [];
      clearHighlights();
      savePosition();
    }
  } else {
    if(currentMoveIndex < moveHistory.length - 1){
      currentMoveIndex++;
      applyMove(moveHistory[currentMoveIndex]);
      turn = oppositeColor(turn);
      updateNotation();
      updateCheckHighlight();
      selected = null;
      possibleMoves = [];
      clearHighlights();
      savePosition();
    }
  }
};

function revertMove(move){
  let {from, to, piece, captured} = move;
  setPiece(from[0], from[1], piece);
  setPiece(to[0], to[1], captured);
}

function applyMove(move){
  let {from, to, piece} = move;
  setPiece(to[0], to[1], piece);
  setPiece(from[0], from[1], '');
}

function updateNotation() {
  let notationText = '';
  for(let i=0; i<=currentMoveIndex; i++) {
    if(i%2===0)
      notationText += `${Math.floor(i/2)+1}. `;
    notationText += moveHistory[i].notation + ' ';
    if(i%2===1)
      notationText += '\n';
  }
  movesElem.textContent = notationText;
}

// Запуск конфетти при мате
function runConfetti() {
  const colors = ['#fce18a', '#ff726d', '#b48def', '#f4306d', '#8ee3ef'];
  for(let i=0; i<100; i++){
    const div = document.createElement('div');
    div.classList.add('confetti-piece');
    document.body.appendChild(div);
    div.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
    div.style.left = Math.random() * window.innerWidth + 'px';
    div.style.top = (Math.random()*50) + 'px';
    
    div.style.animationDuration = 2 + Math.random()*1.5 + 's';
    div.style.animationDelay = (Math.random()*0.5) + 's';
    setTimeout(() => div.remove(), 3500);
  }
}

// Меню изменение тем
function setTheme(name){
  if(!themes[name]) name = 'classic';
  document.body.style.setProperty('--light-square', themes[name].light);
  document.body.style.setProperty('--dark-square', themes[name].dark);
  document.body.style.setProperty('--highlight-square', themes[name].highlight);
  localStorage.setItem('theme', name);
}

themeSelect.onchange = () => {
  setTheme(themeSelect.value);
};

btnClear.onclick = () => {
  if(confirm('Вы действительно хотите очистить доску и начать новую игру?')){
    renderBoardStart();
    savePosition();
  }
};

window.addEventListener('beforeunload', savePosition);

// Инициализация
function init(){
  const savedTheme = localStorage.getItem('theme') || 'classic';
  themeSelect.value = savedTheme;
  setTheme(savedTheme);

  loadPosition();
  enableDraggable();
}

init();

</script>

</body>
</html>
